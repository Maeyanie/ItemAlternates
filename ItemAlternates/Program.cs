using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Text.RegularExpressions;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins;
using Noggog;
using Newtonsoft.Json;

namespace ItemAlternates
{
    public class Program
    {
        private static Lazy<ProgramSettings>? _settings;
        public static ProgramSettings Settings => _settings?.Value ?? throw new ArgumentNullException();

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "ItemAlternates.esp")
                .SetAutogeneratedSettings("Settings", "Settings.json", out _settings)
                .Run(args);
        }

        private struct ReplacementEntry
        {
            public Regex match;
            public string replace;

            public ReplacementEntry(Regex match, string replace)
            {
                this.match = match;
                this.replace = replace;
            }
            public ReplacementEntry(string match, string replace)
            {
                this.match = new Regex(match);
                this.replace = replace;
            }
        }

        private struct Replacers
        {
            public Replacers() { }
            public Dictionary<FormKey, string> formkey = [];
            public Dictionary<string, string> editorid = [];
            public List<ReplacementEntry> pattern = [];
        }
        private static readonly Replacers replacers = new();

        private struct PresetFile
        {
            public List<string>? Replacements;
            public List<string>? Patterns;
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Console.WriteLine("\nLoading custom entries...");
            LoadPreset(Settings.Replacements, Settings.Patterns);

            if (Settings.LoadPresets)
            {
                if (state.ExtraSettingsDataPath.HasValue)
                {
                    DirectoryPath path = state.ExtraSettingsDataPath.Value + @"\Presets";
                    Console.WriteLine($"Loading presets from {path}...");
                    if (!path.Exists) path.Create();
                    foreach (var file in path.EnumerateFiles())
                    {
                        if (!file.ToString().EndsWith(".json")) continue;
                        Console.WriteLine($"\t{file}");
                        try
                        {
                            string text = File.ReadAllText(file);
                            PresetFile preset = JsonConvert.DeserializeObject<PresetFile>(text);
                            LoadPreset(preset.Replacements, preset.Patterns);
                        } catch (Exception ex)
                        {
                            Console.WriteLine($"Failed reading {file}: {ex.Message}");
                        }
                    }
                }
                DirectoryPath dataPresets = state.DataFolderPath + @"\ItemAlternates";
                Console.WriteLine($"Loading presets from {dataPresets}...");
                if (dataPresets.Exists)
                {
                    foreach (var file in dataPresets.EnumerateFiles())
                    {
                        if (!file.ToString().EndsWith(".json")) continue;
                        Console.WriteLine($"\t{file}");
                        try
                        {
                            string text = File.ReadAllText(file);
                            PresetFile preset = JsonConvert.DeserializeObject<PresetFile>(text);
                            LoadPreset(preset.Replacements, preset.Patterns);
                        } catch (Exception ex)
                        {
                            Console.WriteLine($"Failed reading {file}: {ex.Message}");
                        }
                    }
                }
            }
            Console.WriteLine("Ready.\n");



            var items = state.LoadOrder.PriorityOrder.IItem().WinningOverrides();
            Console.WriteLine($"Checking {items.Count()} items...");

            long itemCount = 0;
            long matchCount = 0;
            long llCount = 0;
            long checkCount = 0;
            HashSet<string> unmatched = [];
            foreach (var item in items)
            {
                itemCount++;
                if (item.EditorID == null) continue;

                if (replacers.formkey.TryGetValue(item.FormKey, out string? parentName))
                {
                    Console.WriteLine($"Found match: {item.FormKey} matches {parentName}");

                    IItemGetter? parentItem = GetItem(state, parentName);
                    if (parentItem != null)
                    {
                        if (CloneStats(state, item, parentItem))
                            Console.WriteLine("Copied stats.");

                        long changes = CloneLLs(state, item, parentItem);
                        Console.WriteLine($"Copied {changes} LL entries.\n");
                        llCount += changes;
                        unmatched.Remove(item.EditorID);
                        continue;
                    }

                    Console.WriteLine($"Could not find parent item {parentName}\n");
                    unmatched.Add(item.EditorID);
                }

                if (replacers.editorid.TryGetValue(item.EditorID, out parentName))
                {
                    Console.WriteLine($"Found match: {item.EditorID} matches {parentName}");

                    IItemGetter? parentItem = GetItem(state, parentName);
                    if (parentItem != null)
                    {
                        if (CloneStats(state, item, parentItem))
                            Console.WriteLine("Copied stats.");

                        long changes = CloneLLs(state, item, parentItem);
                        Console.WriteLine($"Copied {changes} LL entries.\n");
                        llCount += changes;
                        unmatched.Remove(item.EditorID);
                        continue;
                    }

                    Console.WriteLine($"Could not find parent item {parentName}\n");
                    unmatched.Add(item.EditorID);
                }

                foreach (var entry in replacers.pattern)
                {
                    checkCount++;
                    if (entry.match.IsMatch(item.EditorID))
                    {
                        matchCount++;
                        Console.WriteLine($"Found match: {item.EditorID} matches {entry.match}");

                        parentName = entry.match.Replace(item.EditorID, entry.replace);
                        Console.WriteLine($"After replacement, EditorID is: {parentName}");

                        IItemGetter? parentItem = GetItem(state, parentName);
                        if (parentItem != null)
                        {
                            if (CloneStats(state, item, parentItem))
                                Console.WriteLine("Copied stats.");

                            long changes = CloneLLs(state, item, parentItem);
                            Console.WriteLine($"Copied {changes} LL entries.\n");
                            llCount += changes;
                            unmatched.Remove(item.EditorID);
                            break;
                        }

                        Console.WriteLine($"Could not find parent item {parentName}\n");
                        unmatched.Add(item.EditorID);
                    } else
                    {
                        if (Settings.Debug) Console.WriteLine($"No match for {item.EditorID}\n");
                    }
                }

            }

            Console.WriteLine($"All done. Checked {itemCount} items with {checkCount} checks. Found {matchCount} matches and cloned {llCount} LL entries.\n");
            Console.WriteLine("Items matched which could not find a parent:");
            foreach (var item in unmatched)
            {
                Console.WriteLine($"\t{item}");
            }
            Console.WriteLine();
        }

        private static bool CloneStats(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IItemGetter item, IItemGetter parentItem)
        {
            if (item is IArmorGetter iag)
            {
                //var armor = state.PatchMod.Armors.GetOrAddAsOverride(item);
                var armor = iag.DeepCopy();
                if (parentItem is not IArmorGetter parentArmor) return false;
                bool dirty = false;

                if (armor.ArmorRating != parentArmor.ArmorRating)
                {
                    armor.ArmorRating = parentArmor.ArmorRating;
                    dirty = true;
                }
                if (armor.Weight != parentArmor.Weight)
                {
                    armor.Weight = parentArmor.Weight;
                    dirty = true;
                }
                if (armor.Value != parentArmor.Value)
                {
                    armor.Value = parentArmor.Value;
                    dirty = true;
                }

                if (dirty) state.PatchMod.Armors.Set(armor);
            } else if (item is IWeaponGetter iwg)
            {
                //var weapon = state.PatchMod.Weapons.GetOrAddAsOverride(item);
                var weapon = iwg.DeepCopy();
                if (parentItem is not IWeaponGetter parentWeapon) return false;
                if (weapon.BasicStats == null || parentWeapon.BasicStats == null) return false;
                bool dirty = false;

                if (weapon.BasicStats.Damage != parentWeapon.BasicStats.Damage)
                {
                    weapon.BasicStats.Damage = parentWeapon.BasicStats.Damage;
                    dirty = true;
                }
                if (weapon.BasicStats.Weight != parentWeapon.BasicStats.Weight)
                {
                    weapon.BasicStats.Weight = parentWeapon.BasicStats.Weight;
                    dirty = true;
                }
                if (weapon.BasicStats.Value != parentWeapon.BasicStats.Value)
                {
                    weapon.BasicStats.Value = parentWeapon.BasicStats.Value;
                    dirty = true;
                }

                if (dirty) state.PatchMod.Weapons.Set(weapon);
            } else if (item is IAmmunitionGetter img)
            {
                var ammo = img.DeepCopy();
                if (parentItem is not IAmmunitionGetter parentAmmo) return false;
                bool dirty = false;

                if (ammo.Damage != parentAmmo.Damage)
                {
                    ammo.Damage = parentAmmo.Damage;
                    dirty = true;
                }
                if (ammo.Weight != parentAmmo.Weight)
                {
                    ammo.Weight = parentAmmo.Weight;
                    dirty = true;
                }
                if (ammo.Value != parentAmmo.Value)
                {
                    ammo.Value = parentAmmo.Value;
                    dirty = true;
                }

                if (dirty) state.PatchMod.Ammunitions.Set(ammo);
            } else if (item is IWeightValueGetter iwvg)
            {
                if (iwvg.Weight == ((IWeightValueGetter)parentItem).Weight
                    && iwvg.Value == ((IWeightValueGetter)parentItem).Value) {
                    return false;
                }

                IWeightValue? newItem = null;
                if (item is IAlchemicalApparatusGetter)
                {
                    newItem = state.PatchMod.AlchemicalApparatuses.GetOrAddAsOverride(item);
                } else if (item is IIngestibleGetter)
                {
                    newItem = state.PatchMod.Ingestibles.GetOrAddAsOverride(item);
                } else if (item is IIngredientGetter)
                {
                    newItem = state.PatchMod.Ingredients.GetOrAddAsOverride(item);
                } else if (item is IKeyGetter)
                {
                    newItem = state.PatchMod.Keys.GetOrAddAsOverride(item);
                } else if (item is ILightGetter)
                {
                    newItem = state.PatchMod.Lights.GetOrAddAsOverride(item);
                } else if (item is IMiscItemGetter)
                {
                    newItem = state.PatchMod.MiscItems.GetOrAddAsOverride(item);
                } else if (item is IScrollGetter)
                {
                    newItem = state.PatchMod.Scrolls.GetOrAddAsOverride(item);
                } else if (item is ISoulGemGetter)
                {
                    newItem = state.PatchMod.SoulGems.GetOrAddAsOverride(item);
                }

                if (newItem != null)
                {
                    newItem.Weight = ((IWeightValueGetter)parentItem).Weight;
                    newItem.Value = ((IWeightValueGetter)parentItem).Value;
                }
            }
            return true;
        }

        private static long CloneLLs(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IItemGetter item, IItemGetter parentItem)
        {
            long ret = 0;
            foreach (var li in state.LoadOrder.PriorityOrder.LeveledItem().WinningOverrides())
            {
                if (li.Entries == null) continue;

                var newLi = li.DeepCopy();
                if (newLi.Entries == null) continue;
                bool dirty = false;

                foreach (var lie in li.Entries)
                {
                    if (lie.Data == null) continue;
                    if (lie.Data.Reference.FormKey == parentItem.FormKey)
                    {
                        if (Settings.Debug) Console.WriteLine($"Found LL reference: {li.Print()}");

                        var newLie = lie.DeepCopy();
                        if (newLie.Data == null)
                        {
                            Console.WriteLine("Copied Levelled Item Data is null!");
                            continue;
                        }
                        newLie.Data.Reference = item.ToLink();
                        newLi.Entries.Add(newLie);
                        dirty = true;
                        ret++;
                    }
                }

                if (dirty)
                {
                    if (Settings.Debug) Console.WriteLine($"After patch: {newLi.Print()}");
                    state.PatchMod.LeveledItems.Set(newLi);
                }
            }

            foreach (var lc in state.LoadOrder.PriorityOrder.Container().WinningOverrides())
            {
                if (lc.Items == null) continue;

                var newLc = lc.DeepCopy();
                if (newLc.Items == null) continue;
                bool dirty = false;

                foreach (var li in lc.Items)
                {
                    if (li.Item.Item.FormKey == parentItem.FormKey)
                    {
                        if (Settings.Debug) Console.WriteLine($"Found Container reference: {li.Print()}");

                        var newLi = li.DeepCopy();
                        newLi.Item.Item = item.ToLink();
                        newLc.Items.Add(newLi);
                        dirty = true;
                        ret++;
                    }
                }

                if (dirty)
                {
                    if (Settings.Debug) Console.WriteLine($"After patch: {newLc.Print()}");
                    state.PatchMod.Containers.Set(newLc);
                }
            }
            return ret;
        }

        private static IItemGetter? GetItem(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, string name)
        {
            IItemGetter? item;
            if (FormKey.TryFactory(name, out var parentFID))
            {
                if (state.LinkCache.TryResolve<IItemGetter>(parentFID, out item))
                {
                    if (Settings.Debug) Console.WriteLine($"Found item by FID: {item.Print()}");
                    else Console.WriteLine($"Found item by FID: {item.FormKey}");
                    return item;
                }
            }

            if (state.LinkCache.TryResolve<IItemGetter>(name, out item))
            {
                if (Settings.Debug) Console.WriteLine($"Found item by EID: {item.Print()}");
                else Console.WriteLine($"Found item by EID: {item.FormKey}");
                return item;
            }

            return null;
        }

        private static bool LoadPreset(List<string>? replacements, List<string>? patterns)
        {
            if (replacements != null)
            {
                foreach (string entry in replacements)
                {
                    var split = entry.Split('>');
                    if (split.Length != 2)
                    {
                        Console.WriteLine($"Invalid manual replacement: {entry}"
                            + "Format should be: ModItem > OriginalItem");
                        return false;
                    }

                    var key = split[0].Trim();
                    var value = split[1].Trim();

                    if (FormKey.TryFactory(key, out var formKey))
                    {
                        replacers.formkey.TryAdd(formKey, value);
                    } else
                    {
                        replacers.editorid.TryAdd(key, value);
                    }
                }
            }

            if (patterns != null)
            {
                foreach (string entry in Settings.Patterns)
                {
                    var split = entry.Split('>');
                    if (split.Length != 2)
                    {
                        Console.WriteLine($"Invalid replacement pattern: {entry}"
                            + "Format should be: Pattern > Substitution");
                        return false;
                    }
                    try
                    {
                        replacers.pattern.Add(new ReplacementEntry(split[0].Trim(), split[1].Trim()));
                    } catch (Exception e)
                    {
                        Console.WriteLine($"Failed to compile regular expression pattern \"{split[0].Trim()}\"\n{e.Message}");
                        return false;
                    }
                }
            }
            return true;
        }
    }
}
